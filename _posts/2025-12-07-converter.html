<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Seismic HTML to Word Converter</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
  <style>
    /* Ensure icons display properly */
    .lucide-icon { display: inline-block; vertical-align: middle; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useCallback, useMemo, useEffect } = React;
    
    // Simple icon components using Lucide
    const Icon = ({ name, className = "w-4 h-4" }) => {
      const ref = React.useRef(null);
      useEffect(() => {
        if (ref.current && lucide && lucide[name]) {
          ref.current.innerHTML = '';
          const svg = lucide.createElement(lucide[name]);
          svg.classList.add(...className.split(' '));
          ref.current.appendChild(svg);
        }
      }, [name, className]);
      return <span ref={ref} className="inline-flex items-center" />;
    };
    
    // Parse Seismic HTML into structured content
    const parseSeismicHtml = (html) => {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const content = [];
      
      const widgets = doc.querySelectorAll('[data-testid]');
      const accordionMap = new Map();
      const widgetToAccordion = new Map();
      
      widgets.forEach((widget) => {
        const testId = widget.getAttribute('data-testid');
        
        if (testId === 'page.accordion') {
          let title = 'Untitled Section';
          const virtualTextEl = widget.querySelector('.seismic-page-divider-view-text-virtual');
          if (virtualTextEl && virtualTextEl.textContent.trim()) {
            title = virtualTextEl.textContent.trim();
          } else {
            const titleEl = widget.querySelector('.seismic-page-divider-view-text');
            if (titleEl && titleEl.textContent.trim()) {
              title = titleEl.textContent.trim();
            }
          }
          
          const headerEl = widget.querySelector('.seismic-page-divider-view');
          let level = 2;
          if (headerEl) {
            if (headerEl.classList.contains('__heading1')) level = 1;
            else if (headerEl.classList.contains('__heading2')) level = 2;
            else if (headerEl.classList.contains('__heading3')) level = 3;
          }
          
          accordionMap.set(widget, { title, level, children: [] });
        } else {
          const parentAccordion = widget.closest('[data-testid="page.accordion"]');
          if (parentAccordion && accordionMap.has(parentAccordion)) {
            widgetToAccordion.set(widget, parentAccordion);
          }
        }
      });
      
      widgets.forEach((widget, idx) => {
        const testId = widget.getAttribute('data-testid');
        if (testId === 'seismic-page-richContent') return;
        
        const parentAccordion = widgetToAccordion.get(widget);
        
        if (testId === 'page.paragraph') {
          const richContent = widget.querySelector('.seismic-page-RichTextView-content');
          if (richContent) {
            const parsed = parseParagraphContent(richContent);
            if (parentAccordion) {
              accordionMap.get(parentAccordion).children.push({ type: 'paragraph', id: `${idx}`, ...parsed });
            } else {
              content.push({ type: 'paragraph', id: idx, ...parsed });
            }
          }
        } 
        else if (testId === 'page.table') {
          const table = widget.querySelector('table');
          if (table) {
            const tableData = parseTable(table);
            if (parentAccordion) {
              accordionMap.get(parentAccordion).children.push({ type: 'table', id: `${idx}`, table: tableData });
            } else {
              content.push({ type: 'table', id: idx, table: tableData });
            }
          }
        }
        else if (testId === 'page.accordion') {
          const accordionData = accordionMap.get(widget);
          content.push({ type: 'accordion', id: idx, title: accordionData.title, level: accordionData.level, children: accordionData.children });
        }
        else if (testId === 'page.divider') {
          const titleEl = widget.querySelector('.seismic-page-divider-view-text');
          const title = titleEl ? titleEl.textContent.trim() : '';
          
          const headerEl = widget.querySelector('.seismic-page-divider-view');
          let level = 2;
          if (headerEl) {
            if (headerEl.classList.contains('__heading1')) level = 1;
            else if (headerEl.classList.contains('__heading3')) level = 3;
          }
          
          content.push({ type: 'divider', id: idx, title, level });
        }
      });
      
      return content;
    };

    const parseParagraphContent = (element) => {
      const results = [];
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = element.innerHTML;
      const capturedTexts = new Set();
      
      const headingData = [];
      tempDiv.querySelectorAll('h1, h2, h3').forEach(heading => {
        const tagName = heading.tagName.toLowerCase();
        const text = heading.textContent.trim();
        if (!text) return;
        headingData.push({ type: tagName, content: text, element: heading });
        capturedTexts.add(text);
      });
      
      tempDiv.querySelectorAll('span[style*="font-size"]').forEach(span => {
        const fontSize = span.style.fontSize;
        const size = parseInt(fontSize);
        const text = span.textContent.trim();
        if (!text || capturedTexts.has(text)) return;
        
        if (size >= 28) {
          headingData.push({ type: 'h1', content: text, element: span });
          capturedTexts.add(text);
        } else if (size >= 20) {
          headingData.push({ type: 'h2', content: text, element: span });
          capturedTexts.add(text);
        } else if (size >= 16) {
          const isBold = span.querySelector('b, strong') || span.closest('b, strong') || span.innerHTML.includes('<b>');
          if (isBold) {
            headingData.push({ type: 'h3', content: text, element: span });
            capturedTexts.add(text);
          }
        }
      });
      
      const listItems = [];
      tempDiv.querySelectorAll('li').forEach(li => {
        let level = 0;
        let parent = li.parentElement;
        while (parent) {
          if (parent.tagName === 'UL' || parent.tagName === 'OL') level++;
          parent = parent.parentElement;
        }
        
        const liClone = li.cloneNode(true);
        liClone.querySelectorAll('ul, ol').forEach(el => el.remove());
        const text = liClone.textContent.trim();
        
        if (text && !capturedTexts.has(text)) {
          let htmlContent = liClone.innerHTML;
          htmlContent = htmlContent
            .replace(/<span[^>]*>\s*<\/span>/gi, '')
            .replace(/<span[^>]*>(.*?)<\/span>/gi, '$1')
            .replace(/<br\s*\/?>/gi, '')
            .replace(/&nbsp;/gi, ' ')
            .replace(/\s+/g, ' ')
            .trim();
          htmlContent = htmlContent.replace(/<a[^>]*>(.*?)<\/a>/gi, '$1');
          htmlContent = htmlContent.replace(/<\/?u>/gi, '');
          
          const hasInlineFormatting = /<(b|strong|i|em)[^>]*>/i.test(htmlContent);
          
          listItems.push({ 
            type: 'listitem', 
            content: text, 
            htmlContent: hasInlineFormatting ? htmlContent : null,
            level: level,
            element: li 
          });
          capturedTexts.add(text);
        }
      });
      
      const textBlocks = [];
      const allDivs = tempDiv.querySelectorAll('div');
      
      allDivs.forEach((div, idx) => {
        if (div.closest('ul, ol')) return;
        if (div.closest('h1, h2, h3, h4, h5, h6, .seismic-page-anchor-container')) return;
        
        const directChildDivs = Array.from(div.children).filter(child => {
          if (child.tagName !== 'DIV') return false;
          if (child.closest('h1, h2, h3, h4, h5, h6, .seismic-page-anchor-container')) return false;
          return true;
        });
        if (directChildDivs.length > 0) return;
        
        const clone = div.cloneNode(true);
        clone.querySelectorAll('h1, h2, h3, h4, h5, h6, .seismic-page-anchor-container, ul, ol, div').forEach(el => el.remove());
        let text = clone.textContent;
        
        const isNbspOnly = /^[\s\u00A0]*$/.test(text);
        text = text.trim();
        
        if (!text || text.length === 0 || isNbspOnly) {
          const hasBr = clone.querySelector('br');
          if (hasBr || isNbspOnly) {
            textBlocks.push({ type: 'break', content: '', element: div });
          }
          return;
        }
        
        if (capturedTexts.has(text)) return;
        
        let isSubstring = false;
        for (const captured of capturedTexts) {
          if (captured.includes(text) && text.length <= captured.length) {
            isSubstring = true;
            break;
          }
        }
        if (isSubstring) return;
        
        const htmlClone = div.cloneNode(true);
        htmlClone.querySelectorAll('h1, h2, h3, h4, h5, h6, .seismic-page-anchor-container, ul, ol, div').forEach(el => el.remove());
        
        let htmlContent = htmlClone.innerHTML;
        htmlContent = htmlContent
          .replace(/<span[^>]*>\s*<\/span>/gi, '')
          .replace(/<span[^>]*>(.*?)<\/span>/gi, '$1')
          .replace(/<br\s*\/?>/gi, '')
          .replace(/&nbsp;/gi, ' ')
          .replace(/\s+/g, ' ')
          .trim();
        
        const hasInlineFormatting = /<(b|strong|i|em)[^>]*>/i.test(htmlContent);
        
        let fontSize = null;
        const fontSpan = div.querySelector('span[style*="font-size"]');
        if (fontSpan) {
          const match = fontSpan.style.fontSize.match(/(\d+)/);
          if (match) fontSize = parseInt(match[1]);
        }
        
        textBlocks.push({ 
          type: 'text', 
          content: text, 
          htmlContent: hasInlineFormatting ? htmlContent : null,
          element: div, 
          fontSize 
        });
        capturedTexts.add(text);
      });
      
      const inlineElements = [];
      Array.from(tempDiv.childNodes).forEach((node, idx) => {
        if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'DIV') return;
        if (node.nodeType === Node.ELEMENT_NODE && /^H[1-6]$/.test(node.tagName)) return;
        if (node.nodeType === Node.ELEMENT_NODE && (node.tagName === 'UL' || node.tagName === 'OL')) return;
        
        let text = '';
        if (node.nodeType === Node.TEXT_NODE) {
          text = node.textContent.trim();
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          text = node.textContent.trim();
        }
        
        if (!text || /^[\s\u00A0]*$/.test(text)) return;
        if (capturedTexts.has(text)) return;
        
        let isSubstring = false;
        for (const captured of capturedTexts) {
          if (captured.includes(text) && text.length <= captured.length) {
            isSubstring = true;
            break;
          }
        }
        if (isSubstring) return;
        
        let isItalic = false;
        let isBold = false;
        
        if (node.nodeType === Node.ELEMENT_NODE) {
          isItalic = node.tagName === 'I' || node.tagName === 'EM' || node.querySelector('i, em');
          isBold = node.tagName === 'B' || node.tagName === 'STRONG' || node.querySelector('b, strong');
        }
        
        let textType = 'text';
        if (isBold && isItalic) textType = 'bolditalic';
        else if (isBold) textType = 'bold';
        else if (isItalic) textType = 'italic';
        
        inlineElements.push({ type: textType, content: text, element: node });
        capturedTexts.add(text);
      });
      
      const allContent = [...headingData, ...listItems, ...textBlocks, ...inlineElements];
      
      allContent.sort((a, b) => {
        const position = a.element.compareDocumentPosition(b.element);
        if (position & Node.DOCUMENT_POSITION_FOLLOWING) return -1;
        if (position & Node.DOCUMENT_POSITION_PRECEDING) return 1;
        return 0;
      });
      
      const finalResults = allContent.map(item => ({
        type: item.type,
        content: item.content,
        htmlContent: item.htmlContent || null,
        fontSize: item.fontSize || null,
        level: item.level || null
      }));
      
      const deduped = [];
      finalResults.forEach((el, idx) => {
        if (el.type === 'break') {
          const prev = deduped[deduped.length - 1];
          if (prev && (prev.type === 'h1' || prev.type === 'h2' || prev.type === 'h3')) return;
          deduped.push(el);
          return;
        }
        if (!el.content || el.content.length === 0) return;
        const isDupe = deduped.some(d => d.content === el.content);
        if (!isDupe) deduped.push(el);
      });
      
      return { parsedContent: deduped, content: element.textContent.trim() };
    };

    const parseTable = (table) => {
      const rows = [];
      const tableRows = table.querySelectorAll('tr');
      
      tableRows.forEach(tr => {
        const row = [];
        const cells = tr.querySelectorAll('td, th');
        
        cells.forEach(cell => {
          const clone = cell.cloneNode(true);
          clone.querySelectorAll('br').forEach(br => br.replaceWith('\n\n'));
          
          const divs = clone.querySelectorAll('div');
          divs.forEach(div => {
            const text = div.textContent.trim();
            if (text) div.insertAdjacentText('beforebegin', '\n\n');
          });
          
          let cellContent = clone.textContent;
          cellContent = cellContent.replace(/\u00A0+/g, ' ');
          cellContent = cellContent.replace(/\n\s*\n/g, '\n\n');
          cellContent = cellContent.replace(/[ \t]+/g, ' ');
          cellContent = cellContent.split('\n').map(line => line.trim()).join('\n');
          cellContent = cellContent.trim();
          
          const htmlClone = cell.cloneNode(true);
          htmlClone.querySelectorAll('br').forEach(br => {
            const marker = document.createTextNode('\n\n');
            br.replaceWith(marker);
          });
          htmlClone.querySelectorAll('div').forEach(div => {
            const text = div.textContent.trim();
            if (text) div.insertAdjacentText('beforebegin', '\n\n');
          });
          
          let htmlContent = htmlClone.innerHTML;
          htmlContent = htmlContent.replace(/<span[^>]*>(.*?)<\/span>/gi, '$1');
          htmlContent = htmlContent.replace(/<(\w+)[^>]*>\s*<\/\1>/gi, '');
          htmlContent = htmlContent.replace(/<\/?div[^>]*>/gi, '');
          htmlContent = htmlContent.replace(/&nbsp;/gi, ' ');
          htmlContent = htmlContent.replace(/<a[^>]*>(.*?)<\/a>/gi, '$1');
          htmlContent = htmlContent.replace(/<\/?u>/gi, '');
          htmlContent = htmlContent.replace(/\n\s*\n/g, '\n\n');
          htmlContent = htmlContent.replace(/[ \t]+/g, ' ');
          htmlContent = htmlContent.split('\n').map(line => line.trim()).join('\n');
          htmlContent = htmlContent.trim();
          
          const hasFormatting = /<(b|strong|i|em)[^>]*>/i.test(htmlContent);
          
          row.push({
            content: cellContent,
            htmlContent: hasFormatting ? htmlContent : null
          });
        });
        
        if (row.length > 0) rows.push(row);
      });
      
      return rows;
    };

    const extractSections = (content) => {
      const sections = [];
      let sectionId = 0;
      
      content.forEach((item, idx) => {
        if (item.type === 'divider' && item.title) {
          sections.push({ id: sectionId++, title: item.title, level: 1, contentIndex: idx, type: 'divider', selected: true });
        }
        else if (item.type === 'accordion') {
          sections.push({ id: sectionId++, title: item.title, level: 2, contentIndex: idx, type: 'accordion', selected: true });
        }
        else if (item.type === 'paragraph' && item.parsedContent) {
          item.parsedContent.forEach((el, elIdx) => {
            if (['h1', 'h2', 'h3'].includes(el.type)) {
              const level = parseInt(el.type.charAt(1));
              sections.push({ id: sectionId++, title: el.content, level, contentIndex: idx, type: 'paragraph-header', elementIndex: elIdx, selected: true });
            }
          });
        }
      });
      
      return sections;
    };

    const generateHtmlForWord = (content) => {
      const headerStyles = {
        h1: "mso-style-name:'Heading 1'; mso-outline-level:1; font-size:28px; color:#1a202c; margin:24px 0 12px 0; font-weight:bold;",
        h2: "mso-style-name:'Heading 2'; mso-outline-level:2; font-size:22px; color:#2d3748; margin:20px 0 10px 0; font-weight:bold;",
        h3: "mso-style-name:'Heading 3'; mso-outline-level:3; font-size:16px; color:#4a5568; margin:16px 0 8px 0; font-weight:bold;",
      };
      
      const tableStyle = `style="width:100%; table-layout:fixed; border-collapse:collapse; margin:12px 0;"`;
      const cellStyle = (isHeader) => `style="border:1px solid #333; padding:8px; word-wrap:break-word;${isHeader ? ' font-weight:bold; background-color:#f0f0f0;' : ''}"`;
      const spacerParagraph = '<p style="mso-style-name:\'Normal\'; margin:0; line-height:100%;"><span style="font-size:11pt;">&nbsp;</span></p>';
      
      const endsWithBreak = (parsedContent) => {
        if (!parsedContent || parsedContent.length === 0) return false;
        return parsedContent[parsedContent.length - 1].type === 'break';
      };
      
      const startsWithHeading = (parsedContent) => {
        if (!parsedContent || parsedContent.length === 0) return false;
        const firstType = parsedContent[0].type;
        return ['h1', 'h2', 'h3'].includes(firstType);
      };
      
      const renderParsedContent = (parsedContent) => {
        let html = '';
        let currentListLevel = 0;
        const isListItem = (type) => type === 'listitem';
        
        parsedContent.forEach((el, idx) => {
          const elLevel = el.level || 1;
          
          if (isListItem(el.type)) {
            while (currentListLevel < elLevel) {
              const indent = currentListLevel * 20;
              html += `<ul style="margin:8px 0 8px ${20 + indent}px;">`;
              currentListLevel++;
            }
            while (currentListLevel > elLevel) {
              html += '</ul>';
              currentListLevel--;
            }
            const liContent = el.htmlContent || el.content;
            html += `<li style="margin:4px 0;">${liContent}</li>`;
          } else {
            while (currentListLevel > 0) {
              html += '</ul>';
              currentListLevel--;
            }
            
            const fontStyle = el.fontSize ? `font-size:${el.fontSize}pt;` : '';
            
            if (el.type === 'h1') html += `<h1 style="${headerStyles.h1}">${el.content}</h1>`;
            else if (el.type === 'h2') html += `<h2 style="${headerStyles.h2}">${el.content}</h2>`;
            else if (el.type === 'h3') html += `<h3 style="${headerStyles.h3}">${el.content}</h3>`;
            else if (el.type === 'break') html += spacerParagraph;
            else if (el.type === 'bold') html += `<p style="margin:0 0 0 0;${fontStyle}"><strong>${el.content}</strong></p>`;
            else if (el.type === 'italic') html += `<p style="margin:0 0 0 0;${fontStyle}"><em>${el.content}</em></p>`;
            else if (el.type === 'bolditalic') html += `<p style="margin:0 0 0 0;${fontStyle}"><strong><em>${el.content}</em></strong></p>`;
            else {
              const displayContent = el.htmlContent || el.content;
              html += `<p style="margin:0 0 0 0;${fontStyle}">${displayContent}</p>`;
            }
          }
        });
        
        while (currentListLevel > 0) {
          html += '</ul>';
          currentListLevel--;
        }
        
        return html;
      };
      
      const renderTable = (tableData) => {
        if (!tableData?.length) return '';
        let html = `<table ${tableStyle}>`;
        tableData.forEach((row, rIdx) => {
          html += '<tr>';
          row.forEach(cell => {
            const cellText = typeof cell === 'object' ? cell.content : cell;
            const cellHtmlContent = typeof cell === 'object' ? cell.htmlContent : null;
            const sourceContent = cellHtmlContent || cellText;
            
            const cellHtml = sourceContent
              .split(/\n\n+/)
              .map(para => para.trim())
              .filter(para => para.length > 0)
              .map(para => `<p style="margin:4px 0;">${para}</p>`)
              .join('');
            html += `<td ${cellStyle(rIdx === 0)}>${cellHtml || sourceContent}</td>`;
          });
          html += '</tr>';
        });
        return html + '</table>';
      };
      
      const renderContent = (item) => {
        let html = '';
        switch (item.type) {
          case 'paragraph':
            if (item.parsedContent?.length) {
              html += renderParsedContent(item.parsedContent);
            } else if (item.content) {
              html += `<p style="margin:6px 0;">${item.content}</p>`;
            }
            break;
          case 'table':
            html += renderTable(item.table);
            break;
          case 'divider':
            if (item.title) {
              html += `<h1 style="${headerStyles.h1}">${item.title}</h1>`;
            }
            break;
          case 'accordion':
            html += `<h2 style="${headerStyles.h2}">${item.title}</h2>`;
            item.children?.forEach(child => { html += renderContent(child); });
            break;
        }
        return html;
      };
      
      const needsSpacerBetween = (prevItem, currentItem) => {
        if (!prevItem) return false;
        if (currentItem.type === 'divider' || currentItem.type === 'accordion') return false;
        if (prevItem.type === 'divider' || prevItem.type === 'accordion') return false;
        if (currentItem.type === 'paragraph' && startsWithHeading(currentItem.parsedContent)) return false;
        if (prevItem.type === 'paragraph' && endsWithBreak(prevItem.parsedContent)) return false;
        if (prevItem.type !== currentItem.type) return true;
        if (prevItem.type === 'table' && currentItem.type === 'table') return true;
        return false;
      };
      
      let fullHtml = `<html><head><style>body{font-family:Calibri,Arial,sans-serif;font-size:11pt;max-width:100%;}</style></head><body>`;
      
      content.forEach((item, idx) => {
        const prevItem = idx > 0 ? content[idx - 1] : null;
        if (needsSpacerBetween(prevItem, item)) {
          fullHtml += spacerParagraph;
        }
        fullHtml += renderContent(item);
      });
      
      fullHtml += '</body></html>';
      return fullHtml;
    };

    function SeismicConverter() {
      const [inputText, setInputText] = useState('');
      const [docContent, setDocContent] = useState(null);
      const [sections, setSections] = useState([]);
      const [showPreview, setShowPreview] = useState(false);
      const [activeTab, setActiveTab] = useState('input');
      const [status, setStatus] = useState({ type: '', message: '' });

      // Auto-paste from clipboard on page load
      useEffect(() => {
        const autoPaste = async () => {
          try {
            const text = await navigator.clipboard.readText();
            if (text && (text.includes('seismic') || text.includes('data-testid'))) {
              setInputText(text);
              setStatus({ type: 'success', message: 'Content auto-pasted from clipboard!' });
            }
          } catch (err) {
            // Clipboard access denied or empty - that's fine
          }
        };
        
        // Small delay to ensure page is ready
        setTimeout(autoPaste, 500);
      }, []);

      const parseInput = useCallback(() => {
        try {
          const trimmed = inputText.trim();
          if (!trimmed) {
            setStatus({ type: 'error', message: 'Please paste Seismic HTML content' });
            return null;
          }
          
          const content = parseSeismicHtml(trimmed);
          
          if (content.length === 0) {
            setStatus({ type: 'error', message: 'No content found. Make sure you copied the Seismic article HTML.' });
            return null;
          }
          
          setDocContent(content);
          const extractedSections = extractSections(content);
          setSections(extractedSections);
          
          const tableCount = content.filter(c => c.type === 'table').length;
          setStatus({ type: 'success', message: `Parsed ${content.length} blocks (${tableCount} tables)` });
          return content;
        } catch (err) {
          setStatus({ type: 'error', message: 'Error parsing content: ' + err.message });
          setDocContent(null);
          setSections([]);
          return null;
        }
      }, [inputText]);

      const toggleSection = useCallback((sectionId) => {
        setSections(prev => {
          const updated = [...prev];
          const idx = updated.findIndex(s => s.id === sectionId);
          if (idx === -1) return prev;
          
          const section = updated[idx];
          const newSelected = !section.selected;
          updated[idx] = { ...section, selected: newSelected };
          
          if (!newSelected) {
            for (let i = idx + 1; i < updated.length; i++) {
              if (updated[i].level > section.level) {
                updated[i] = { ...updated[i], selected: false };
              } else break;
            }
          }
          
          if (newSelected) {
            for (let i = idx - 1; i >= 0; i--) {
              if (updated[i].level < section.level) {
                updated[i] = { ...updated[i], selected: true };
                if (updated[i].level === 1) break;
              }
            }
          }
          
          return updated;
        });
      }, []);

      const selectAll = useCallback(() => setSections(prev => prev.map(s => ({ ...s, selected: true }))), []);
      const deselectAll = useCallback(() => setSections(prev => prev.map(s => ({ ...s, selected: false }))), []);

      const getFilteredContent = useCallback(() => {
        if (!docContent) return null;
        if (sections.length === 0) return docContent;
        
        const sectionsByContentIndex = new Map();
        sections.forEach(s => {
          sectionsByContentIndex.set(s.contentIndex, s);
        });
        
        const getOwningSection = (contentIdx) => {
          if (sectionsByContentIndex.has(contentIdx)) {
            return sectionsByContentIndex.get(contentIdx);
          }
          let owningSection = null;
          for (let i = contentIdx - 1; i >= 0; i--) {
            if (sectionsByContentIndex.has(i)) {
              owningSection = sectionsByContentIndex.get(i);
              break;
            }
          }
          return owningSection;
        };
        
        return docContent.filter((item, idx) => {
          const asSection = sectionsByContentIndex.get(idx);
          if (asSection) return asSection.selected;
          const owner = getOwningSection(idx);
          if (!owner) return true;
          return owner.selected;
        });
      }, [docContent, sections]);

      const handlePreview = useCallback(() => {
        const content = docContent || parseInput();
        if (content) {
          setShowPreview(true);
          setActiveTab('preview');
        }
      }, [docContent, parseInput]);

      const handleClear = useCallback(() => {
        setInputText('');
        setDocContent(null);
        setSections([]);
        setShowPreview(false);
        setActiveTab('input');
        setStatus({ type: '', message: '' });
      }, []);

      const handleCopyForWord = useCallback(() => {
        let content = getFilteredContent();
        if (!content) {
          content = parseInput();
          if (!content) return;
        }
        
        const html = generateHtmlForWord(content);
        const blob = new Blob([html], { type: 'text/html' });
        const clipboardItem = new ClipboardItem({ 'text/html': blob });
        
        navigator.clipboard.write([clipboardItem]).then(() => {
          setStatus({ type: 'success', message: 'Copied! Paste directly into Word (Ctrl+V / Cmd+V)' });
        }).catch(() => {
          navigator.clipboard.writeText(html).then(() => {
            setStatus({ type: 'success', message: 'Copied as HTML. Use Paste Special > HTML in Word.' });
          }).catch(err => {
            setStatus({ type: 'error', message: 'Failed to copy: ' + err.message });
          });
        });
      }, [getFilteredContent, parseInput]);

      const filteredContent = useMemo(() => getFilteredContent(), [getFilteredContent]);

      const renderPreview = () => {
        const content = filteredContent || docContent;
        if (!content || !showPreview) return null;
        
        return (
          <div className="p-4 bg-white rounded border max-h-96 overflow-y-auto">
            <h3 className="font-bold text-lg mb-3 border-b pb-2">Document Preview ({content.length} items)</h3>
            {content.map((item, idx) => (
              <div key={idx} className="mb-3">
                {item.type === 'divider' && item.title && (
                  <div className="mt-4">
                    <h1 className="text-2xl font-bold text-gray-900 my-3">{item.title}</h1>
                  </div>
                )}
                {item.type === 'paragraph' && (
                  <div className="text-sm">
                    {item.parsedContent?.map((el, elIdx) => {
                      if (el.type === 'h1') return <h1 key={elIdx} className="text-2xl font-bold text-gray-900 my-3">{el.content}</h1>;
                      if (el.type === 'h2') return <h2 key={elIdx} className="text-xl font-bold text-gray-800 my-2">{el.content}</h2>;
                      if (el.type === 'h3') return <h3 key={elIdx} className="text-lg font-bold text-gray-700 my-2">{el.content}</h3>;
                      if (el.type === 'listitem') {
                        const indent = ((el.level || 1) - 1) * 16;
                        if (el.htmlContent) {
                          return <li key={elIdx} className="ml-4" style={{ marginLeft: `${16 + indent}px` }} dangerouslySetInnerHTML={{ __html: el.htmlContent }} />;
                        }
                        return <li key={elIdx} className="ml-4" style={{ marginLeft: `${16 + indent}px` }}>{el.content}</li>;
                      }
                      if (el.type === 'bold') return <p key={elIdx} className="font-bold">{el.content}</p>;
                      if (el.type === 'italic') return <p key={elIdx} className="italic">{el.content}</p>;
                      if (el.type === 'bolditalic') return <p key={elIdx} className="font-bold italic">{el.content}</p>;
                      if (el.type === 'break') return <div key={elIdx} className="h-4"></div>;
                      if (el.htmlContent) {
                        return <p key={elIdx} className="text-gray-700" dangerouslySetInnerHTML={{ __html: el.htmlContent }} />;
                      }
                      return <p key={elIdx} className="text-gray-700">{el.content}</p>;
                    })}
                  </div>
                )}
                {item.type === 'table' && item.table && (
                  <div className="my-4 overflow-x-auto">
                    <table className="text-xs border-collapse w-full">
                      <tbody>
                        {item.table.map((row, rIdx) => (
                          <tr key={rIdx}>
                            {row.map((cell, cIdx) => {
                              const cellText = typeof cell === 'object' ? cell.content : cell;
                              const cellHtmlContent = typeof cell === 'object' ? cell.htmlContent : null;
                              const sourceContent = cellHtmlContent || cellText;
                              
                              return (
                                <td key={cIdx} className={`border border-gray-300 p-2 ${rIdx === 0 ? 'font-bold bg-gray-100' : ''}`}>
                                  {sourceContent.split(/\n\n+/).map((para, pIdx) => (
                                    cellHtmlContent 
                                      ? <p key={pIdx} className={pIdx > 0 ? 'mt-2' : ''} dangerouslySetInnerHTML={{ __html: para }} />
                                      : <p key={pIdx} className={pIdx > 0 ? 'mt-2' : ''}>{para}</p>
                                  ))}
                                </td>
                              );
                            })}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}
                {item.type === 'accordion' && (
                  <div className="my-3 ml-2 relative pl-5">
                    <div className="absolute left-0 top-0 bottom-0 w-1 bg-green-400 rounded-full"></div>
                    <h2 className="text-xl font-bold text-gray-900 mb-2">{item.title}</h2>
                    {item.children?.map((child, cIdx) => (
                      <div key={cIdx} className="mt-2 text-sm">
                        {child.type === 'paragraph' && child.parsedContent && (
                          <div>
                            {child.parsedContent.map((el, elIdx) => {
                              if (el.type === 'h1') return <h1 key={elIdx} className="text-xl font-bold text-gray-900 my-2">{el.content}</h1>;
                              if (el.type === 'h2') return <h2 key={elIdx} className="text-lg font-bold text-gray-800 my-2">{el.content}</h2>;
                              if (el.type === 'h3') return <h3 key={elIdx} className="text-base font-bold text-gray-700 my-1">{el.content}</h3>;
                              if (el.type === 'listitem') {
                                const indent = ((el.level || 1) - 1) * 16;
                                if (el.htmlContent) {
                                  return <li key={elIdx} className="ml-4" style={{ marginLeft: `${16 + indent}px` }} dangerouslySetInnerHTML={{ __html: el.htmlContent }} />;
                                }
                                return <li key={elIdx} className="ml-4" style={{ marginLeft: `${16 + indent}px` }}>{el.content}</li>;
                              }
                              if (el.type === 'break') return <div key={elIdx} className="h-3"></div>;
                              if (el.htmlContent) {
                                return <p key={elIdx} className="text-gray-600" dangerouslySetInnerHTML={{ __html: el.htmlContent }} />;
                              }
                              return <p key={elIdx} className="text-gray-600">{el.content}</p>;
                            })}
                          </div>
                        )}
                        {child.type === 'paragraph' && !child.parsedContent && child.content && (
                          <p className="text-gray-600">{child.content}</p>
                        )}
                        {child.type === 'table' && child.table && (
                          <table className="text-xs border-collapse w-full mt-2">
                            <tbody>
                              {child.table.map((row, rIdx) => (
                                <tr key={rIdx}>
                                  {row.map((cell, cIdx2) => {
                                    const cellText = typeof cell === 'object' ? cell.content : cell;
                                    const cellHtmlContent = typeof cell === 'object' ? cell.htmlContent : null;
                                    const sourceContent = cellHtmlContent || cellText;
                                    
                                    return (
                                      <td key={cIdx2} className={`border border-gray-300 p-1 ${rIdx === 0 ? 'font-bold bg-gray-50' : ''}`}>
                                        {sourceContent.split(/\n\n+/).map((para, pIdx) => (
                                          cellHtmlContent
                                            ? <p key={pIdx} className={pIdx > 0 ? 'mt-1' : ''} dangerouslySetInnerHTML={{ __html: para }} />
                                            : <p key={pIdx} className={pIdx > 0 ? 'mt-1' : ''}>{para}</p>
                                        ))}
                                      </td>
                                    );
                                  })}
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        )}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            ))}
          </div>
        );
      };

      const renderSectionsTab = () => {
        if (sections.length === 0) {
          return (
            <div className="p-4 text-gray-500 text-center">
              No sections found. Paste HTML and click Preview first.
            </div>
          );
        }
        
        return (
          <div className="p-4">
            <div className="flex gap-2 mb-4">
              <button onClick={selectAll} className="flex items-center gap-1 px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded">
                <Icon name="CheckSquare" className="w-4 h-4" /> Select All
              </button>
              <button onClick={deselectAll} className="flex items-center gap-1 px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded">
                <Icon name="Square" className="w-4 h-4" /> Deselect All
              </button>
            </div>
            <div className="border rounded max-h-80 overflow-y-auto">
              {sections.map((section) => (
                <div
                  key={section.id}
                  className={`flex items-center gap-2 p-2 hover:bg-gray-50 border-b last:border-b-0 cursor-pointer ${!section.selected ? 'opacity-50' : ''}`}
                  style={{ paddingLeft: `${(section.level - 1) * 20 + 8}px` }}
                  onClick={() => toggleSection(section.id)}
                >
                  <input type="checkbox" checked={section.selected} onChange={() => toggleSection(section.id)} className="w-4 h-4 rounded" onClick={(e) => e.stopPropagation()} />
                  <span className={`text-xs px-1.5 py-0.5 rounded ${section.level === 1 ? 'bg-blue-100 text-blue-700' : section.level === 2 ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-600'}`}>
                    H{section.level}
                  </span>
                  <span className={`text-sm ${section.level === 1 ? 'font-bold' : section.level === 2 ? 'font-semibold' : ''}`}>
                    {section.title}
                  </span>
                </div>
              ))}
            </div>
            <div className="mt-3 text-sm text-gray-500">
              {sections.filter(s => s.selected).length} of {sections.length} sections selected
            </div>
          </div>
        );
      };

      return (
        <div className="min-h-screen bg-gray-100 p-4">
          <div className="max-w-4xl mx-auto">
            <div className="bg-white rounded-lg shadow-lg p-5">
              <div className="flex items-center gap-3 mb-4">
                <Icon name="FileText" className="w-7 h-7 text-blue-600" />
                <h1 className="text-xl font-bold text-gray-800">Seismic HTML to Word Converter</h1>
              </div>
              
              <div className="flex border-b mb-4">
                <button onClick={() => setActiveTab('input')} className={`px-4 py-2 text-sm font-medium border-b-2 transition ${activeTab === 'input' ? 'border-blue-600 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700'}`}>
                  Input HTML
                </button>
                <button onClick={() => { if (docContent) setActiveTab('sections'); }} className={`px-4 py-2 text-sm font-medium border-b-2 transition flex items-center gap-1 ${activeTab === 'sections' ? 'border-blue-600 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700'} ${!docContent ? 'opacity-50 cursor-not-allowed' : ''}`}>
                  <Icon name="List" className="w-4 h-4" /> Sections
                </button>
                <button onClick={() => { if (docContent) { setShowPreview(true); setActiveTab('preview'); } }} className={`px-4 py-2 text-sm font-medium border-b-2 transition flex items-center gap-1 ${activeTab === 'preview' ? 'border-blue-600 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700'} ${!docContent ? 'opacity-50 cursor-not-allowed' : ''}`}>
                  <Icon name="Eye" className="w-4 h-4" /> Preview
                </button>
              </div>

              {activeTab === 'input' && (
                <textarea
                  value={inputText}
                  onChange={(e) => setInputText(e.target.value)}
                  placeholder="Paste your Seismic HTML here (use the bookmarklet to copy it)..."
                  className="w-full h-48 p-3 border border-gray-300 rounded-lg font-mono text-sm resize-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              )}
              
              {activeTab === 'sections' && renderSectionsTab()}
              {activeTab === 'preview' && renderPreview()}
              
              <div className="flex gap-3 mt-4">
                <button onClick={handlePreview} disabled={!inputText.trim()} className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition">
                  <Icon name="Eye" className="w-4 h-4" /> Preview
                </button>
                <button onClick={handleCopyForWord} disabled={!inputText.trim()} className="flex items-center gap-2 px-4 py-2 bg-orange-500 text-white rounded hover:bg-orange-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition">
                  <Icon name="ClipboardPaste" className="w-4 h-4" /> Copy for Word
                </button>
                <button onClick={handleClear} className="flex items-center gap-2 px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition">
                  <Icon name="Trash2" className="w-4 h-4" /> Clear
                </button>
              </div>

              {status.message && (
                <div className={`flex items-center gap-2 p-3 rounded mt-4 ${status.type === 'error' ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'}`}>
                  <Icon name={status.type === 'error' ? 'AlertCircle' : 'CheckCircle'} className="w-5 h-5" />
                  <span className="text-sm">{status.message}</span>
                </div>
              )}

              <div className="mt-4 p-3 bg-amber-50 border border-amber-200 rounded text-sm text-amber-800">
                <strong>Tip:</strong> Use the bookmarklet on a Seismic page to copy the HTML, then this page will auto-paste it!
              </div>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<SeismicConverter />);
  </script>
</body>
</html>
